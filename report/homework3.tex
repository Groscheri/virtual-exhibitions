\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[font=small,labelfont=bf, textfont=it]{caption}
\usepackage[bottom=2cm, left=3.7cm, right=3.7cm]{geometry} % to change padding
\usepackage{verbatim}
\usepackage{subcaption} % for multi figure
\usepackage{enumitem} % -- label item
\usepackage{tabularx}
\usepackage{color}
\usepackage[usenames, dvipsnames]{xcolor} % color
\usepackage[framemethod=TikZ]{mdframed} % box
\usepackage{listings} % code
\usepackage{amsmath} % align* maths
\usepackage{wrapfig}
\usepackage[bookmarks, hidelinks]{hyperref} % clickable links
\usepackage{graphicx} % includegraphics
\usepackage[section]{placeins} % float inside section
\usepackage{indentfirst}

\setlength\parindent{0pt}
\setlength{\parskip}{1em}



% Titre
\title{Distributed Artificial Intelligence \& Intelligent Agents \\ DAIIA - Homework 3}
\author{Laurentiu CAPATINA \& Quentin LEMAIRE}

\begin{document}

  \maketitle % build title

  \section{Introduction}
  
  The aim of this homework is to implement practical scenarios using deep 
mechanisms of the JADE\footnote{Java Agent DEvelopment: \href{http://jade.tilab.com/}{http://jade.tilab.com/}} 
  platform. Such mechanisms involve knowledge and understanding of containers and self 
  generation of agent's concepts.

  % TODO to complete

  % aliases
  \newcommand{\pa}{\textit{Profiler Agent}}
  \newcommand{\cu}{\textit{Curator Agent}}
  \renewcommand{\to}{\textit{Tour Guide Agent}}
  \newcommand{\am}{\textit{Artist Manager Agent}}
  
  \section{Implementation}
  
  \subsection{N queens}

  \subsubsection{Description}
  
  % TODO what's the problem ?
  \textit{N queens problem} is a well-known problem in Artificial Intelligence because it is often 
  used to demonstrate that problems that, at first glance, seem difficult to solve are not that 
  hard to solve if we concentrate and study the possible issues of the problem.
  
  \subsubsection{Protocol}
  
  \paragraph{Model}
  Before building any communication protocol betweens the Queens, it was necessary to implement a 
  small model in order to create the rules of the game and the chest where to Queens stand. That's 
  why a class called \textit{Chest} appeared in the model. The aim of this class is to provide 
  methods to help Queens in their decision making. First, the chest was virtually implemented as a 
  single table (list) of integers from 0 to $n^2-1$. Of course, such a table isn't useful at all and 
  we only created a table representing the position of the $n$ queens. This table contains $n$ entries 
  and each $i$ of them contains the value (position) of the queen number $i$.
  \begin{verbatim}
	n = 4
      ===========
      00 01 02 03
      04 05 06 07
      08 09 10 11
      12 13 14 15
      ===========
queens = [04, 13, 02, 11]
  \end{verbatim}

  Methods provided are the following:
  \begin{itemize}
   \item serialize: in order to send chest through content ACLMessage
   \item fromSerial: build a chest from a serialize content
   \item setQueen: set queen $i$ to a position $p$
   \item findPlace: find place within a column
   \item findPlaceFromPrevious: find place without taking previous positions of the queen into account
   \item possible: is it possible to place a queen here ?
   \item checkPosition \& check are private methods which allow checking position parameter and position 
   compared to other queens (same row ? same column ? same diagonal ?)
  \end{itemize}

  \paragraph{Communication}  
  Each queen represents a column in the chest and could only communicate with the previous or the following queen (column before and column after). 
  For the first queen, she can only talk to the next one (second column), and for the last queen, she can only speak with the previous queen. Once every 
  queens are launched (created dynamically with \textit{ContainerController} class in \textit{QueenFactoryAgent} class), they look for their previous 
  and/or next queen(s) using registrations and subscriptions to and from \textit{Directory Facilitator} (DF). Once this is done, a backtracking process 
  can start with the following protocol:
  \begin{enumerate}
   \item First queen (column number 0) starts with positioning in the first column (often first line)
   \item First queen sends a message to next queen asking her to position herself if she can
   \item Second queen receives the message with associated model and try to place herself on the chest
   \begin{itemize}
    \item If she succeeds, she sends a message to the following queen and then step 2 is repeated.
    \item If she fails, she sends a message back to the previous queen asking her to change the position of the queen.
   \end{itemize}
   \item If a queen receives a message from the next queen, it means ``change your position'' i.e. no solution was found.
   Queen receiving the message tries to place her queen in another position (not forgetting the previous position in order 
   to avoid infinite loops). Then, conditions and actions from step 3 are repeated.
   \item If last queen succeeds in placing herself, problem is solved
   \item If first queen doesn't succeed in placing all of her position, problem is impossible to solve or every solution has 
   been found.
  \end{enumerate}
  
  \paragraph{Some results}
\begin{verbatim}
n = 04 | solution = [04, 13, 02, 11]
n = 08 | solution = [0, 33, 58, 43, 20, 53, 14, 31]
n = 16 | solution = [0, 33, 66, 19, 196, 133, 214,
                     183, 232, 89, 250, 107, 60, 
                     173, 126, 159]
\end{verbatim}

For each problem, we could have searched all the possible solutions backtracking even 
though we had found a solution in order to find it all (stacking them).
  
Concerning time, this algorithm is really huge resources consuming. There are lots of 
communication and backtracking before finding a solution with $n = 16$. This is way much 
easier with $n = 4$ but this problem doesn't seem to be solvable in that way for big $n$ 
values. Even $n = 100$ seems very very hard nay impossible to compute in an affordable 
time for a computer machine.
  
  % TODO Lancement  -gui main:Agents.QueenFactoryAgent

  \subsection{Multiple containers}

  \subsubsection{Description}

  The idea of this task is to create a distributed Dutch auction between the Artist Manager
  and the Curators in 2 different containers.
  We have chosen the following scenario:
  \begin{itemize}
  \item The Artist Manager is \textit{cloned} in two different containers
  \item Four Curators are created with different strategies associated
  \item Each Curators is \textit{moved} in one of the two containers 
  \item An auction takes place in each container
  \item The main Artist Manager receives the two auction results and keeps the best one

  \subsubsection{Implementation}

  \paragraph{Controller Agent}

  An introduction of a new Agent was necessary in order to handle the creation of containers
  as well as the identification of all possible locations on the platform. Moreover, using the
  subscription in the DF Agent, it manages to get all Artist Manager Agents in order to
  launch their cloning. It will also create the four curators and will take care of their
  moving process.

  \parapgraph{Cloning}

  This process gives the oportunity to have an identical agent in another container with a different
  name. Consequently, it is based on the \textit{CloneAction} and \textit{MobileDescriptionClass} classes.
  The main parameters are the new destination and the new name of the agent.
  In order to execute the cloning, an \textit{ACLMessage} is sent to the corresponding instance of the agent
  with the performative \textit{REQUEST}. This message has a specific language (\textit{SLCodec}) and a specific
  ontology (\textit{MobilityOntology}).

  \parapgraph{Moving}

  Moving is a mobility very similar to cloning. The difference is that the agent won't be present in
  two different containers, it will simple move from one to a new destination. All other aspects mentioned
  in the case of cloning are valid for moving as well.

  \parapgraph{Distributed Auction}

  The main idea is to apply the auction but only to a subset of all Curators. Consequently, this implies
  applying a filter on the research of all Curators before launching the auction. The \textit{destination}
  of the moved Curators may serve as filter while searching the services of Curators in the DF Agent. It is
  mandatory that the mobility precedes the DF research so that the two behaviours would be sequential.

  \parapgraph{Main Artist Manager}
  This specific Artist Manager which is in the main container shouldn't launch an auction. It should listen
  to the other two Artist Managers for the winner of their actions in their containers and he will eventually
  choose the best offer. The communication will be done using \textit{ACLMessages} with a \textit{block()}
  function at the level of the main Artist Manager in order to capture the two results. This part
  of the implementation still needs to be tested as it is not fully functional.

  \section{Conclusion}
  
  This homework was an opportunity to implement the N Queen problems using agents based on the JADE framework
  but also to implement the mobility of Curators and Artist Manager Agents in order to create a distributed
  Dutch auction.

\end{document}
